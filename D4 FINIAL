我把你这批「第四层」存档的核心收敛点，按**你刚才重新收拢后的口径**（Process=调度室；对象=车厢；对象管理器负责等待/提交/清算）整理成**最终 D4（交互模板层）**。其中“命令事实二元组、Busy鸵鸟、Freeze红灯、Clear/Reset语义、完整生命周期链”与你发的闭合版本一致。

---

## 0) 先把我不再“追问发散”的两件事钉死

**A) PhysicalDone 的事实来源：由对象自己定义、自己置位。**
第四层不规定它的格式/来源；只规定：它是“物理达成事实”，且**发生在 Active 阶段**，并且**Commit 后不再需要它继续保持**（对象内部可在 Commit 或 Clear 时清掉自己的 PhysicalDoneLatch）。

**B) 生命周期就是 6 段（你刚纠正的那条链）**
**Idle → Cmd(New) → Active → PhysicalDone → Commit → Clear → Idle**
并且：**只有 Idle 能接新命令**；其它阶段外界变化“语义上无意义”。

---

## 1) 第四层的“对象交互模板”最终定义（D4 Final）

### 1.1 对外输入（模板统一口）

对象对外只需要这些“事务口”，别再让 Process 碰对象内部细节：

* **Cmd / CmdID**：命令事实（二元组）
* **CommitPulse / CommitCmdID**：外部语义确认（单拍）
* **ClearPulse / ClearCmdID**：外部显式清算（单拍）  ← 你最后决定用它做 POC
* **Freeze / Reset / Mode**：全局干预（Freeze=冻结推进；Reset=系统级否定历史）

> 这就是你说的“火车基础结构”：车头/车轮/车厢接口统一，长度不同只是对象内部实现。

---

## 2) 命令事实与接收窗口（抗 Tᴿ / Tᴼ）

### R1 命令事实（唯一事实形式）

**CommandFact := (Cmd, CmdID)**

* **CmdID=0 无效**
* **NewCmd := (CmdID≠0) AND (CmdID≠LastCmdID)**

### R2 唯一接收窗口

**只有在 Idle 且 Freeze=FALSE 时接收 NewCmd**，并且**同拍锁定**：

* `LastCmdID := CmdID`
* `锁定 Cmd + 参数快照`
* `Busy := TRUE`
* `LifeState := Active`

### R3 Busy 鸵鸟原则（你强调的点）

当 **Busy=TRUE（非 Idle）**：

* **完全拒绝新命令**
* **不感知 CmdID 变化**
* **不缓存、不排队、不记账**
  外界变化对它“语义上等于没发生”。

> 这条就是你问我 Tᴼ 零容忍的落点：**任何语义不能依赖扫描先后**。Busy 时去“偷看外界变化”会把语义重新引入时序依赖，必须禁止。

---

## 3) Freeze（红绿灯）最终口径

### F1 Freeze 是“冻结推进”（不改变物理现实）

当 **Freeze=TRUE**：

* **不允许 Idle→Active（入口红灯）**
* **不推进生命周期（Active/PhysicalDone/Commit/Clear 都不推进）**
* **不更新 old/edge 记忆，不消费邮箱，不动计时器**（你已确认“计时器冻结”）
* 内部状态保持原样

当 **Freeze=FALSE**：

* **恢复冻结前的逻辑**（你纠正我的关键点：解冻不引入新规则，不做“追溯补账”）

---

## 4) PhysicalDone / Commit / Clear 的职责边界（你要的“车到站”语义）

### P1 PhysicalDone（对象内部事实）

* 发生位置：**Active 阶段**
* 含义：**物理条件满足，但语义未完成**
* 由对象内部置位（可 latch）

### C1 Commit（外部显式调用，语义确认）

* **CommitPulse 必须单拍**（你已确认：Process/管理器端“每扫先清，再按条件置 TRUE”）
* **CommitCmdID 必须等于对象当前事务 CmdID（=StepCmdID）**
* 触发条件模板：外部看到对象 `PhysicalDone=TRUE` 后，才允许发 CommitPulse
* Commit 成功后：对象进入“已确认完成”的语义态（例如 `LogicalDoneLatched=TRUE`）

> 你问“什么叫显式调用，Physical→Commit 算不算显式调用？”
> **算。** 因为 CommitPulse 是外部明确发出的“语义确认动作”，不是对象内部自然消失。

### CL1 Clear（显式清算，让对象回到可接新命令的 Idle）

你最后拍板：**先按 ClearCmdID（带事务号）做 POC**，那 D4 就按这个闭合：

* **ClearPulse 必须单拍**
* **ClearCmdID 必须等于当前事务 CmdID（=StepCmdID）**
* Clear 发生后对象必须：

  * `Busy := FALSE`
  * `回到 Idle`
  * `清掉本事务的 Key/中间锁存（包括对象内部的 PhysicalDoneLatch/LogicalDonePending 等）`

**重要：Clear 不清 Alarm/LastError；Reset 才清。**（你已确认）

> 你提出的比喻我按你口径写死：

* **Commit**：调度台已确认“车到站”（语义确认）
* **Clear**：车厢自己“清零路障/清垃圾”，恢复可接下一单
* **Reset**：拖车+恢复秩序（否定历史）

---

## 5) Reset（系统级否定连续性）

当 **Reset=TRUE**（或 Mode=Reset）：

* 清：`LastCmdID / Busy / DoneLatch / Key / Alarm / LastError` 全部回到确定初始状态
* 含义：**否定语义世界历史**，重新建立“确定起点”

---

## 6) 你问的“生命周期每段做什么、哪些信号在哪段允许置位”——给你一张硬表

* **Idle**

  * 允许：接收 NewCmd（锁定 Cmd/CmdID/参数）
  * 不允许：Commit/Clear（收到也应忽略或按错误处理，但模板建议忽略）

* **Active**

  * 允许：对象内部推进动作、计时（Freeze 时冻结）
  * 允许置位：PhysicalDone（对象内部事实）
  * 不允许：接收新 CmdID

* **PhysicalDone**

  * 含义：物理已达成、等待外部语义确认
  * 允许：外部发 CommitPulse（匹配 CmdID）
  * 不允许：接收新 CmdID

* **Commit**

  * 动作：对象锁存 LogicalDone（语义完成）
  * 结果：进入“等待 Clear”或“可被 Clear 的稳定态”
  * 不允许：接收新 CmdID

* **Clear**

  * 动作：清本事务中间态，回 Idle
  * 不允许：在 Clear 前接新 CmdID（否则语义重叠）

* **Reset（全局干预，不算生命周期段，是“系统橡皮擦”）**

  * 随时可覆盖，把一切拉回确定初始态

---

## 7) 现在第四层还缺不缺“第五层”？

**不缺。**
你现在要的“第四层”，本质是**对象交互模板（事务口 + 生命周期口径 + 干预口径）**，到你最后这版（CommitPulse + ClearPulse/ClearCmdID）已经闭合了。

**但我必须把“你担心一致性”的真因说透：**

* **第四层闭合 ≠ 代码文本天然唯一。**
  同一语义在实现层依然可能出现多种“结构等价写法”（IF 顺序、变量命名、是否拆分 Collect/Settle、计时器调用位置等）。
* 你要的是“语义一致 + 结构一致”，那还需要的不是“第五层语义”，而是**“代码生成约束/模板化输出规则”**（比如：固定段落顺序、固定状态编号、固定变量命名、固定 Collect→Settle→Synthesize 四段式骨架）。这属于**生成器的版式规范**，不是控制哲学新增一层。

---

## 8) 你问 Codex 一致性会不会比我好

如果你指的是**“同一份模板 + 同一份约束 → 更稳定地产出同构代码”**，通常 **Codex 类更偏代码模型**会更稳一些；但决定一致性的**第一因素不是模型名字**，而是你是否：

1. 给了**唯一的模板骨架**（段落顺序固定）
2. 给了**不允许自由发挥的输出约束**（命名/状态/时序骨架固定）
3. 最好是**用 DSL/IR → 生成器**，把“自由写代码”变成“填空式生成”

你现在已经把 1) 的语义模板钉死了；接下来我们做的第二件事（你说的“做个模版出来，让你无话可说”）就是把 2) 也钉死——这样换哪个对话、换哪个模型，都只能长一个样。

---

如果你同意我上面这份 **D4 Final（事务交互模板）** 的口径，我下一步就按你要求做两件事：

1. 用它去**对照检查**你发的 SyncBroker/Servo/Cylinder/Process：哪些地方违背“Idle-only 接收 / Busy 鸵鸟 / Commit/Clear 单拍且 CmdID 匹配 / Freeze 冻结计时”等硬条款。
2. 给出一份**“对象模板代码骨架（结构同构版）”**：固定段落顺序 + 固定变量命名 + 固定 Collect/Settle 结构，确保“结构一致”。
