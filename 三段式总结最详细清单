行，我按你的要求：**不偷懒、用最详细的工程语言**把“三段式”完整写成一份“可当规范/可验收/可复用”的版本，并且我已经**存入你的研究锚点**（以后你只要提到其中关键词，我会被强制拉回这条推理轨道）。

下面我把同一份内容在聊天里再给你一遍，方便你直接复制到文档里（内容与已写入锚点一致）。

---

# 三段式闭合控制哲学（终版·详细规范）

## 总原则

控制系统的工程级收敛依赖“三段式闭合结构”，其目标不是“能跑”，而是：

* **可证明**：对所有现实干扰，行为被定义且唯一
* **可复核**：任何人按同一规则检查，结论一致
* **可移植**：换 PLC 平台/HMI/MES，仅改接口，不改控制语义

硬性原则（零容忍项）：

1. **任何逻辑不得依赖扫描时序成立（Tᴼ 零容忍）**
   不能出现“if 顺序不同结论不同”“同拍先后导致语义不唯一”。

2. **任何控制意图必须抗重复（Tᴿ）**
   抖动、重发、长 TRUE、网络重传都不能造成重复执行或重复完成。

3. **Clear 必须显式发生**
   禁止靠“Done 一拍自然消失”、禁止 Busy=NOT Done 这类隐式结算。

分层职责不可互相替代：

* **状态机只调度不执行**
* **事务只承载时间语义不承担模式外观**
* **矩阵只负责证明不参与运行**

---

## 第一段：生命周期 × 干扰矩阵（证明层 / 校验系统）

### 1) 定义

矩阵用于穷举并校验：
**“一次控制事务的生命”在遭遇现实世界必然干扰时，系统行为是否被明确定义、且唯一。”**

它不参与运行、不写代码、不做功能——只做证明与验收。

### 2) 生命周期（纵轴）——一次控制事务的生命

固定为：

**Idle → Cmd(New) → Active → PhysicalDone → Commit → Clear → Idle**

并且必须满足以下语义约束：

* **Cmd / CmdID 是事务起点（事实）**
  事务起点不是沿、不是 Busy 置位，而是可被“事实化”的输入变化（如 CmdID/token）。

* **PhysicalDone ≠ 逻辑完成**
  PhysicalDone 只代表物理条件满足（到位、反馈成立、条件达成），但“上层语义”尚未确认。

* **Commit 是上层确认 / 语义生效点**
  Commit 由上层（Process/HMI/状态机）作出语义确认，不等同设备动作行为。

* **Clear 必须显式发生**
  Clear 是事务责任边界的终点，必须被明确触发与落地，禁止自然消失。

### 3) 干扰（横轴）——不是异常，是现实必然事件

干扰必须全覆盖且作为矩阵横轴存在，而不是“异常分支”：

* **N**：NewCmd（新事务注入）
* **S**：Stop
* **R**：Reset
* **E**：Error / Fault
* **A**：Abort
* **C**：Commit 干预/确认介入
* **D**：Disable / PowerOff（能量/使能丢失）
* **P**：Pause / Freeze（推进冻结）
* **L**：Loop / Repeat（生命周期回绕）
* **Tᴿ**：重复指令干扰（抖动/重发/长 TRUE/网络重传）
* **Tᴼ**：时序依赖干扰（扫描顺序/同拍先后影响语义）

### 4) 校验要求（验收判据）

对任一 **生命周期阶段 × 干扰维度**，系统行为必须满足：

* **明确**：没有“看情况”“一般不会发生”
* **唯一**：同一输入条件下没有多个可能结果
* **无歧义**：不靠读者脑补，不靠经验
* **与扫描时序无关**：改变代码顺序/同拍先后，语义仍一致

若存在以下任一情况 → 判定体系不收敛：

* 依赖 if 顺序成立
* Busy/Done 存在隐含关系（Busy=NOT Done、Done 一拍作为结算）
* Clear 无显式语义，靠自然回落
* 对 Tᴿ/Tᴼ 没有明确策略

### 5) 矩阵产物是什么

矩阵产物不是代码，而是**每一格的策略声明 + 必要不变量**：

* 策略声明（每格必须给出唯一答案）：
  忽略 / 覆盖 / 重启 / 排队 / 冻结 / 硬复位 / 报警锁存 / 允许提交 / 禁止提交…

* 必要不变量（保障 Tᴼ/Tᴿ 不失效）：
  例如 LastCmdID 同拍锁定、冻结期间 DonePulse 强制 FALSE、Reset 是否清事实结果等。

---

## 第二段：事务流程（执行语义层 / 一次且仅一次）

### 1) 定义

事务用于承载：

> **一条控制意图如何在不依赖扫描时序的前提下，被准确执行一次，并被显式结算。**

最小完备语义单元（字段可以合并，但语义不可缺）：

* Cmd / CmdID
* Busy
* PhysicalDone
* Done（或 DonePulse）
* Commit
* Clear

### 2) 事实与实现分离（核心原则）

* **CmdID 是外部事实**：代表“世界注入了一条意图”
* **Busy/State 是内部实现**：代表“我正在处理”

因此：

* 新事务判定必须基于事实（CmdID/token 变化）
* 并且必须在接收同拍完成“锁定”（LastCmdID/CurToken 更新）
* **不得用 Busy 是否已置位去假设外部事实的时序**（否则必定 Tᴼ）

### 3) 生命周期覆盖（不得缺段）

每条命令必须完整覆盖：

Start → Active → PhysicalDone → Commit → Clear

禁止：

* Busy=NOT Done
* Done 一拍 = 自动结算
* 物理完成 = 逻辑完成
* Clear 依赖“下个 scan 自然回落”

### 4) 抗干扰策略必须可声明且可实现

对 Stop/Freeze/Reset/Fault/ModeChange 等干扰必须定义：

* 是否冻结推进
* 计时是否暂停/继续
* 是否允许提交
* 是否作废并回 Idle
* 是否保留事实结果（例如发布已发生是否可撤销）

对 **Tᴿ** 必须定义 Busy 期间策略（唯一答案）：

* 忽略 / 覆盖 / 重启 / 排队

对 **Tᴼ** 必须定义可证明的不变量：

* 同拍锁定
* 判定不依赖 if 顺序
* Pulse 一拍化有统一清零策略
* 输出语义在任意扫描顺序下一致

### 5) 可诊断性（工程可验收）

事务应提供可复盘信号（至少能回答“为什么”）：

* 当前阶段 / Busy
* LastCmdID/Token
* 计时器状态（是否冻结、ET/剩余、是否超时）
* LastError（超时/冲突/无效等分类）
* 统计量（LifeCnt/LastTime/AvgTime 等，如你工程要求）

---

## 第三段：状态机（外观与调度层 / 模式与权限）

### 1) 定义

状态机是系统对外的可观测投影与可调度入口（OMAC/PLCopen/自定义）：

* 描述“系统处于什么模式/阶段”
* 负责“权限与调度”
* 不负责“动作如何完成”

### 2) 职责边界（必须守住）

状态机只做三件事：

1. **模式约束**：某些事务在某些模式下禁止/允许
2. **权限管理**：谁能触发什么事务
3. **事务调度**：何时触发哪条事务，何时发 Commit/Clear

状态机禁止做的事：

* 禁止直接根据 I/O 反馈实现完成判定
* 禁止实现计时/互锁/重试等“事务内部语义”
* 禁止把动作执行塞进状态跳转里（否则事务腐烂）

### 3) 层间关系（闭合结构）

* 状态机：决定 **能不能做/何时做**
* 事务：决定 **怎么做对一次**
* 矩阵：决定 **我敢不敢说一定对**

任何一层越权替代另一层都会破坏收敛：

* 状态机执行动作 → 事务腐烂
* 事务内置模式 → 外观失真、不可调度
* 缺矩阵 → 可跑但不可系统性检查

### 4) 移植性目标（你项目的最终目的）

* 状态机采用平台无关语义（OMAC/PLCopen）
* 事务与对象采用自定义结构体与统一映射接口
* 换 PLC 平台/HMI/报警平台 → 仅适配接口，不重写语义

---

如果你要我再加一层“更狠的强化”（更像规范而不是解释），我可以把这份内容再补两部分：

1. **禁止写法清单**（你讨厌的 Done 一拍、Busy=NOT Done、if 顺序成立… 全部写成禁止条款 + 为什么）
2. **对象实现模板**（Sync/Cyl/Servo/Process 统一怎么映射到三段式）

你选一个方向，我继续。
