明白。

你要的不是 HTML。
你要的是：

* 正常网页文字
* 但有**重点加粗**
* 有层级
* 有结构感
* 像我们前面收敛时的表达方式

我按这个格式重新给你整理一版 **第四层最终收敛定义**。

---

# 🔹 第四层 · 事务交互模板（最终收敛版）

---

# 一、生命周期固定链（不可删减）

**Idle
→ Cmd(New)
→ Active
→ PhysicalDone
→ Commit
→ Clear
→ Idle**

这条链是对象的唯一合法事务路径。

任何代码实现必须能映射到这 6 个阶段。

---

# 二、各阶段职责与允许动作

---

## **1️⃣ Idle（唯一接收窗口）**

### 作用

* 唯一允许接收新命令的阶段

### 允许动作

* 判定 `NewCmd`
* 锁存 `LastCmdID`
* 锁存参数快照
* `Busy := TRUE`
* 进入 Active

### 禁止

* 非 Idle 启动事务
* 非 Idle 修改 LastCmdID

---

## **2️⃣ Cmd(New)（瞬时语义点）**

这是一个**语义瞬间**，不是常驻阶段。

### 必须同拍完成

* `LastCmdID := CmdID`
* 参数锁存
* `Busy := TRUE`
* 生命周期进入 Active

不得跨拍。

---

## **3️⃣ Active（执行期）**

### 作用

* 执行物理动作
* 运行内部计时器

### 允许

* Busy = TRUE
* 内部状态推进

### 禁止

* 接收新命令
* 更新 LastCmdID
* 缓存新命令

**鸵鸟原则：Busy 时外界无意义。**

---

## **4️⃣ PhysicalDone（物理完成）**

### 来源

由对象内部定义。

第四层不定义实现形式。

### 语义

* 物理条件成立
* 但语义未完成

### 允许

* 置位 PhysicalDoneLatched

---

## **5️⃣ Commit（语义确认）**

### 来源

来自 Process 的外部确认

### 条件

* CommitPulse 必须是一拍
* CommitCmdID == LastCmdID

### 动作

* LogicalDoneLatched := TRUE
* 清 PhysicalDoneLatched

---

## **6️⃣ Clear（语义清算）**

### 来源

内部语义清算

### 动作

* Busy := FALSE
* 清内部 Key
* 清 Pending
* 停计时器
* 生命周期回到 Idle

**Clear 必须显式发生。**

---

# 三、接收新命令的最终判定公式

```
(NOT Busy)
AND (NOT LogicalDonePending)
AND (State = Idle)
```

只有满足这个条件才允许接收新 CmdID。

---

# 四、Freeze 定义

### 含义

* 冻结逻辑推进
* 冻结计时器

### 行为

* Busy 时：继续内部状态，不接收新命令
* Idle 时：红灯，不允许进入事务
* 解冻拍不启动事务（已确认选 B）

---

# 五、Reset 定义

### 否定历史连续性

动作：

* 清 Alarm
* 清 LastError
* 清事务状态
* 回到系统初始秩序

Reset ≠ Abort

---

# 六、Abort（Mode 触发）

* 由 Mode 切换触发
* 否定当前事务
* 生命周期落点由 Mode 决定（你选 C）

---

# 七、Process 角色（已确认）

Process 是**调度室**：

* 只发 Cmd / CmdID
* 只发 CommitPulse
* 不管理对象内部状态
* 不参与 Clear
* 不关心对象实现

对象是标准车厢。

---

# 结论

现在的第四层：

* 生命周期固定
* 接收窗口固定
* Commit 规则固定
* Clear 规则固定
* Freeze 规则固定
* Reset 规则固定
* Process 职责固定

不存在第五层。

如果以后还出现“需要你再解释”的情况，
那不是缺层，
那是实现偏离结构。

---

现在这版是你要的结构表达形式。

如果你觉得哪一段还模糊，我们只讨论那一段。
