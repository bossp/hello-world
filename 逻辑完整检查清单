好，我直接给你一份可当“审设计标准”的——

# 控制事务设计规范 v1.0

（用来判断：一段控制逻辑是否完整、不漏、不重复、可解耦）

---

## 0. 定义

### 0.1 两条世界线必须分开

* **事务逻辑（Transaction）**：一次命令从 *请求* → *受理* → *执行* → *完成/失败/取消* 的闭环。
* **状态逻辑（State）**：设备此刻所处条件（Enabled/Standstill/Error/HomingDone…），用于**门控**事务，不直接等价事务完成。

> 判定：如果你写出了 “Busy := xxx OR AxisBusy OR …” 但说不清每个 OR 对应哪个事务闭环，那就是状态和事务揉一起了。

### 0.2 事务的最小闭环接口（抽象）

对每条命令，你至少要能回答：

* **Start 条件是什么**（何时算“受理/开始”）
* **Done 条件是什么**（何时算“物理完成”）
* **Commit 条件是什么**（何时算“业务确认完成”）
* **Abort 条件是什么**（何时算“被取消/打断”）
* **Error 条件是什么**（何时算“失败”）
* **Idempotent 条件是什么**（重复下同一命令是否“立即通过”）

---

## 1. 事务标准模型（必须具备的 6 段）

对任何一条命令（POWER_ON / POWER_OFF / ABS / REL / VEL / HOME / STOP / RESET…），都必须能映射到：

1. **Request**：外部发起（CmdID 变化 / Execute 上升沿 / 电平请求变化）
2. **Accept**：控制块接受该请求（进入事务，锁存 CmdID / Kind / Param）
3. **Execute**：向底层发出动作（MC Execute 脉冲 / Enable 电平）
4. **PhysicalDone**：底层动作完成（DonePulse 或 DoneLevel + Kind 匹配）
5. **Commit**：上层确认（CommitPulse + CmdID 绑定），把“物理完成”变成“业务完成”
6. **Close**：清理现场（Busy 归零、锁存清空、统计/诊断落地）

> 你现在的 ServoCtrl_S3 + AxisS3 就是把 4) 拆到 AxisS3，把 5) 放在 ServoCtrl 做“握手锁存”。

---

## 2. 生命周期 × 干扰矩阵（用来检验“完整性”的方法）

### 2.1 生命周期列（每条命令都要过一遍）

* Start（开始）
* Running（执行中）
* Done（物理完成）
* Commit（确认完成）
* Close（退出/清理）

### 2.2 干扰行（每条命令都要考虑）

* **重复同命令**（重复 POWER_OFF、重复 ABS 到同一位置）
* **新命令打断**（CmdID 变化来了新事务）
* **STOP**（停止事务）
* **RESET / ACK**（复位事务）
* **EnablePermit 断开 / Mode 变化**
* **Fault / Error / Aborted**
* **手动介入（ManStop / Jog）**
* **目标已满足（Idempotent）**：例如已在 OFF 又来 OFF；已在位置又来 ABS 同位置

### 2.3 检验方式（像审查清单一样打勾）

对每条命令，画一个表（你可以贴在文档里）：

| 干扰 \ 生命周期           | Start | Running | Done | Commit | Close |
| ------------------- | ----- | ------- | ---- | ------ | ----- |
| 重复同命令               |       |         |      |        |       |
| 新命令打断               |       |         |      |        |       |
| STOP                |       |         |      |        |       |
| RESET               |       |         |      |        |       |
| 失能/模式变更             |       |         |      |        |       |
| Fault/Error/Aborted |       |         |      |        |       |
| 手动介入                |       |         |      |        |       |
| 目标已满足               |       |         |      |        |       |

**每个格子必须写一句话：这个干扰发生在这个阶段时，我的逻辑怎么处理。**
写不出来 = 必漏 bug。

> 你现在遇到的 “OFF 状态再次 OFF → Busy 卡住” 就是：
> **“目标已满足 × Start/Running/Commit” 这一格没写**。

---

## 3. Idempotent（重复命令立即通过）是强制项

### 3.1 规则

如果目标状态已经满足，重复命令必须满足至少一种“立即闭环”：

* 方案 A：**Accept 后立即 PhysicalDone**（同扫描或下一扫描）
* 方案 B：允许进入事务，但 **PhysicalDoneLatch 必须马上置位**，一次 Commit 就能关 Busy
* 方案 C：根本不进入事务（直接忽略请求）——但要非常小心统计与上层期望

### 3.2 你的工程最推荐做法（和你现结构一致）

在 AxisS3 层对 POWER 做“事务化锁存”，并且加入：

* **若 powerOkLevel 已满足且来了新的 powerReqEdge**
  → 产生 Done（或置 PhysicalDoneLatch），让上层一次 Commit 就能清 Busy。

否则就会出现：

* 重复 OFF：PowerLatched=TRUE，但永远等不到“变化”触发 Done
* Commit 清不掉：因为 PhysicalDone 永远不成立

---

## 4. 块间交互规范：脉冲 + 锁存 + 绑定（你这套的核心）

### 4.1 为什么必须锁存

* AxisS3 的 Done 多数是 **脉冲（1 扫描）**
* 上层 CommitPulse 可能晚到、或者与 Done 不同扫描
  所以必须：
* **PhysicalDoneLatch（上层）**：把 DonePulse 保存到 Commit 到来

### 4.2 必须绑定什么

* 绑定 **CmdID**（你已经做了）
* 绑定 **Kind**（通过 DoneKind/ExpectedKind 已做）
* 可选绑定 **ParamToken**（高级：同 CmdID 复用或 ParamIdx 变化时用）

### 4.3 清理规则（必须写在规范里）

PhysicalDoneLatch 只能被这些事件清：

* Commit 成功（Close）
* Abort / Error（失败关闭）
* NewCmd（新事务开始，旧事务作废）
* Reset（可选，看你定义）

---

## 5. Busy 的严谨定义（防止“揉 OR”）

### 5.1 Busy 不是“设备在动”

Busy 是：

> **存在一个“尚未 Close 的事务”。**

所以 Busy 只能由事务状态导出，而不是由状态位拼 OR。

你现在 ServoCtrl_S3 的 Busy 结构正确方向是：

* AutoTxnBusy：事务型 Kind 且未 LogicalDone 且未 Abort
* ManJogBusy：Jog 事务闭环（电平）
* Axis.Q_Busy：只能作为“底层执行中参考”，不能替代事务 Busy（你已经去掉了，这是对的）

---

## 6. 你现在写代码“老觉得少东西”的根因与方法论

### 6.1 根因（很具体）

你不是缺“代码技巧”，你缺的是：

* **把所有命令都强制过一遍“生命周期 × 干扰矩阵”的书写过程**
* 没写就一定漏：尤其是 **目标已满足 / 重复命令 / 命令打断 / STOP/RESET 插入点**

### 6.2 方法论（可落地）

每写一个命令，按顺序做这 5 步，像写工艺表一样：

1. **写事务表**：Start/Running/Done/Commit/Close
2. **写干扰清单**：重复/打断/STOP/RESET/失能/故障/手动/目标已满足
3. **填矩阵一句话**：每格一句话（怎么处理）
4. **落地到代码三件套**：

   * 触发（edge/level）
   * 锁存（latch + bind）
   * 清理（close conditions）
5. **对照“禁止项”检查**（下一节）

---

## 7. 禁止项清单（写完必须自查）

* ❌ 用状态位拼 Busy，却说不清 Busy 对应哪条事务
* ❌ Done/Busy 依赖“变化边沿”，但没处理“目标已满足/重复命令”
* ❌ Done 是脉冲，但上层没有 latch 却想等 Commit
* ❌ STOP/RESET 既当状态又当事务（混用）
* ❌ NewCmd 来了不作废旧事务（或旧 latch 不清）

---

## 8. 一句话总结（可贴给我做你的“哲学前置”）

> **所有命令都是独立事务，必须闭环。**
> 状态只用于门控，不等价完成。
> Done/Commit 用脉冲握手，必须锁存并绑定 CmdID/Kind。
> 每条命令必须经过“生命周期 × 干扰矩阵”审查，尤其处理：重复命令与目标已满足。

---

如果你认可这版 v1.0，我下一步可以把它升级成你真正能用来“审图/审代码”的两个产物（不改你结构）：

1. **《事务审查清单（打印版）》**：一页纸打勾用
2. **《命令语义表模板》**：像你的工艺表一样，一条命令一行，直接驱动实现与测试

你说要哪个，我就按你的工程字段（Cmd / CmdID / Kind / ParamType / ParamIdx / CommitPulse）直接套模板写出来。
