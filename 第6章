好，我直接进入**成文模式**。
下面这两章不是“说明”，而是**你这套体系真正能落地、能验收、能传给任何工程师的工具章节**。
你可以**原样复制**进“一本通”，不需要我再解释。

---

# 第五章

## 如何用【生命周期 × 干扰矩阵】做设计前自检与设计后验收

> 本章不是方法论阐述，而是**工程操作规程（SOP）**。
> 不按本章流程走的设计，一律视为**未经验证**。

---

## 5.1 本章定位

生命周期 × 干扰矩阵是本体系中：

* **唯一的逻辑完整性校验工具**
* **唯一的工程级收敛判据**
* **设计前必须填写**
* **设计后必须验收**

矩阵**不参与运行**，
但它决定代码**有没有资格运行**。

---

## 5.2 矩阵的固定坐标系（不可改）

### 5.2.1 生命周期（纵轴）——一次控制事务的生命

固定为：

1. Idle
2. Cmd / New（事务事实注入）
3. Active（事务执行中）
4. PhysicalDone（物理条件满足）
5. Commit（上层语义确认）
6. Clear（显式结算，回 Idle）

> 注意：
>
> * PhysicalDone ≠ 完成
> * Clear 必须显式发生
> * 禁止合并生命周期阶段以“简化代码”

---

### 5.2.2 干扰全集（横轴）——现实世界必然事件

固定为：

* N：NewCmd
* S：Stop
* R：Reset
* E：Error / Fault
* A：Abort
* C：Commit（上层干预）
* D：Disable / PowerOff
* P：Pause / Freeze
* L：Loop / Repeat
* Tᴿ：重复指令干扰
* Tᴼ：时序依赖干扰

> **Tᴿ / Tᴼ 必须作为独立列存在**
> 不允许“隐含处理”“经验处理”。

---

## 5.3 设计前自检流程（Design-Time）

### Step 1：选定对象或事务

* 对象（Cylinder / Servo / Sync / Process 内部事务）
* 或单条控制事务（如 Servo.MoveAbs）

**一次只检查一个事务**，禁止混写。

---

### Step 2：先画矩阵，不写代码

建立一个表格：

* 行 = 生命周期 6 行
* 列 = 干扰 11 列

此时**不允许打开 IDE**。

---

### Step 3：逐格填写“唯一策略”

每一格必须填写**一句话策略**，形式为：

> 在【生命周期 X】阶段，
> 遇到【干扰 Y】时，
> 系统行为为：【唯一动作定义】。

合法的动作定义示例：

* 忽略
* 冻结推进
* 硬复位回 Idle
* 作废当前事务
* 禁止 Commit
* 允许 Commit
* 重启事务
* 报警锁存并冻结

非法定义示例（直接判不合格）：

* “一般不会发生”
* “看情况”
* “和之前一样”
* “按经验处理”

---

### Step 4：检查三类致命空洞

矩阵填完后，必须重点检查：

#### ❌ 空洞 1：Tᴿ 未定义

* Busy 期间重复 Cmd 怎么处理？
* Freeze 期间重复 Cmd 怎么处理？

未写 = 必炸。

---

#### ❌ 空洞 2：Tᴼ 无不变量

* 是否依赖 Busy / Done 的扫描顺序？
* 是否依赖 if 先后？

若无法写出**与扫描顺序无关的判定规则** → 不合格。

---

#### ❌ 空洞 3：Clear 模糊

* Clear 是否有明确触发点？
* 是否只是“Done 一拍自然回 Idle”？

若 Clear 不能在矩阵中被单独定位 → 不合格。

---

### Step 5：矩阵通过，才允许写代码

> **矩阵未通过，不得进入编码阶段。**

---

## 5.4 设计后验收流程（Review / FAT / SAT）

### Step 1：从代码反推矩阵

不是看代码“像不像对”，而是：

* 每一个 if / 状态 / 计时器
* 都能回指到矩阵中的**某一格**

若存在代码路径**无法定位到矩阵格子** → 直接 Fail。

---

### Step 2：故意制造干扰进行验证

至少验证以下注入：

* Busy 期间重复 Cmd（Tᴿ）
* 同拍 Cmd + Stop
* PhysicalDone 前 Reset
* Freeze 期间 CmdID 抖动
* Commit 同拍 Reset

验证目标不是“系统还能跑”，而是：

> **行为是否与矩阵定义一致。**

---

### Step 3：验收结论标准

* 所有测试行为 = 矩阵定义
  → **通过**

* 任一行为依赖扫描顺序 / if 顺序
  → **不收敛，拒绝验收**

---

## 5.5 本章结论（硬结论）

> **没有通过矩阵自检与验收的系统，
> 不具备工程级成立性。**

---

---

# 第六章

## 控制对象最终模板（Cylinder / Servo / Sync）

> 本章定义的是**对象级最终形态模板**，
> 不是示例代码，而是**语义边界规范**。

---

## 6.1 对象通用硬性结构（所有对象必须满足）

### 6.1.1 对象必须长期存在

* 一个真实执行体
* 对应一个长期存在的对象实例
* 禁止“临时 FB / 即用即弃逻辑”

---

### 6.1.2 对象统一事务接口语义

每个对象至少具备：

* Cmd / CmdID（事实注入）
* Busy（事务进行中）
* PhysicalDone（物理条件满足）
* Done / DonePulse（对外完成）
* Commit / Clear（显式结算）
* LastError / 统计量

---

## 6.2 Cylinder 对象模板

### 6.2.1 Cylinder 的事务语义

典型事务：

* Extend
* Retract

#### PhysicalDone 定义

* 目标位到位传感器成立
* 或在“无反馈模式”下，达到策略定义条件

#### 错误必须在对象内判断

* 双到位冲突
* 超时未到位
* 反馈非法组合

流程不得判断这些错误。

---

### 6.2.2 干扰处理原则（摘要）

* Stop / Pause → Freeze
* Reset → 硬复位回 Idle
* Tᴿ → Busy 期间忽略新 Cmd
* Tᴼ → CmdID 同拍锁定，禁止 Busy 判新事务
* Clear → Commit 同拍 Clear

---

## 6.3 Servo 对象模板

### 6.3.1 Servo 的事务边界

典型事务：

* PowerOn / PowerOff
* Home
* MoveAbs / MoveRel
* Stop / Halt

每个动作 **必须是独立事务**。

---

### 6.3.2 PhysicalDone 的严格区分

* Axis 到位 / InPosition
* ≠ Move 事务完成
* Move 完成 = PhysicalDone + Commit

禁止：

* Axis 状态直接驱动流程跳转
* PLCopen 状态作为事务完成依据

PLCopen 只作为**外观参考**。

---

## 6.4 Sync 对象模板

### 6.4.1 Sync 的事务类型

* Publish
* Wait
* Clear

---

### 6.4.2 核心语义（已验证）

* CmdID 变化 = 事务事实
* Busy 期间忽略新 Cmd（Tᴿ）
* LastCmdID 同拍更新（封 Tᴼ）
* Freeze 期间暂停计时，ET 保留
* Commit 同拍 Clear
* Reset 不清已发布事件（事实不可撤销）

---

## 6.5 对象与 Process 的最终关系

* 对象：

  * 决定“能不能做 / 怎么做 / 什么时候物理完成 / 是否错误”

* Process：

  * 决定“什么时候调度 / 调度谁 / 是否 Commit”

Process **永远不直接操作 IO**，
**永远不判断 PhysicalDone**。

---

## 全书到此的终极判据

> **任何对象、任何流程、任何系统，
> 只要能被矩阵完整描述，
> 就能被工程化证明；
> 不能被矩阵描述的部分，
> 一律不允许存在。**

---

你现在这本“一本通”已经**逻辑闭合**了。
后面要做的，不是再“想”，而是**照这个东西干项目**。

如果你下一步想要：

* 把 **Cylinder / Servo / Sync** 其中一个直接展开成**代码级骨架**
* 或把矩阵做成 **可打印的空表模板**

你一句话，我继续。
