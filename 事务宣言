好，下面这一份就是**可以当“母规范”的版本**。
不是教程、不是解释文，而是**工程规范**——你以后所有 Servo / Cylinder / Process / Sync 都可以直接对齐它。

---

# 控制事务设计规范 v1.0

**Transactional Control Design Specification**

---

## 0. 目的与适用范围

### 0.1 目的

本规范用于约束和指导**工业控制系统中事务型控制逻辑的设计**，确保：

* 控制逻辑 **完整、可证明、不漏分支**
* 事务之间 **解耦、不互相污染**
* 上下层（Process ↔ Control ↔ Axis）**交互清晰**
* 消除 Busy 卡死、Done 丢失、重复命令异常等结构性问题

### 0.2 适用对象

* Servo 控制块（Axis / ServoCtrl）
* 气缸、执行器对象
* 同步点（Sync / Barrier / Token）
* 工艺流程引擎（Process / Step Engine）
* 任意“命令 → 执行 → 完成”的控制对象

---

## 1. 核心设计哲学（不可违背）

### 1.1 事务与状态必须严格区分

> **事务逻辑 ≠ 状态逻辑**

* **事务（Transaction）**

  * 有起点、有过程、有完成、有清理
  * 由“命令”触发
  * 必须闭环

* **状态（State）**

  * 描述当前系统客观事实
  * 不应驱动事务开始
  * 不应承担“完成确认”职责

❌ 禁止把事务逻辑写成“状态 OR 连接”
✅ 必须以事务生命周期为核心建模

---

### 1.2 每一条命令 = 一条独立事务

> **不存在“非事务型命令”**

包括但不限于：

* POWER_ON / POWER_OFF
* STOP
* RESET
* HOME
* MOVE_ABS / MOVE_REL
* MOVE_VEL
* JOG

**每一条命令都必须具备完整应答链路**，哪怕它“什么都不做”。

---

## 2. 事务生命周期模型（强制）

### 2.1 生命周期定义

任何事务**必须**覆盖以下阶段：

| 阶段 | 名称           | 语义          |
| -- | ------------ | ----------- |
| T0 | Idle         | 尚未触发        |
| T1 | Triggered    | 收到命令（边沿）    |
| T2 | Executing    | 已派发到底层      |
| T3 | PhysicalDone | 物理动作完成      |
| T4 | LogicalDone  | 上层确认完成      |
| T5 | Cleared      | 清理完成，回 Idle |

> ❗ 少任意一个阶段，该事务即为**不完整事务**

---

### 2.2 PhysicalDone 与 LogicalDone 的强制区分

* **PhysicalDone**

  * 由底层对象产生（Axis / Device）
  * 表示“事情已经发生”

* **LogicalDone**

  * 由上层确认（Commit）
  * 表示“这次事务被系统接受并消化”

> **PhysicalDone 必须可被锁存
> LogicalDone 必须由 Commit 驱动**

---

## 3. 干扰维度模型（必须显式考虑）

### 3.1 干扰类型定义

在事务生命周期的**任意时刻**，可能发生以下干扰：

| 符号 | 干扰类型                       |
| -- | -------------------------- |
| N  | Normal（正常路径）               |
| S  | Stop                       |
| R  | Reset                      |
| E  | Error                      |
| A  | Abort / CommandAborted     |
| C  | Commit                     |
| D  | Duplicate（重复命令）            |
| P  | Preempt（新命令抢占）             |
| L  | License / Enable / Mode 变化 |

---

### 3.2 二维完整性原则（核心判定法）

> **事务完整性 = 生命周期 × 干扰 的全覆盖**

即：

> 若存在任意一个
> **(生命周期阶段 × 干扰类型)**
> 未被明确语义定义
> → 该逻辑不完整

这是**硬判定规则**，不是经验判断。

---

## 4. 重复命令（Duplicate）规范（强制）

### 4.1 定义

当系统已处于“目标满足状态”，再次收到**语义等价的命令**，称为 Duplicate。

示例：

* 已 OFF，再发 POWER_OFF
* 已在目标位置，再发同一个 ABS

---

### 4.2 强制行为

| 当前阶段            | Duplicate 语义            |
| --------------- | ----------------------- |
| T0 Idle         | **必须立即产生 PhysicalDone** |
| T2 Executing    | 可忽略或拒绝                  |
| T3 PhysicalDone | 不得清除完成                  |
| T4 LogicalDone  | 不得重复计数                  |

❌ 禁止进入 Busy
❌ 禁止等待不存在的物理动作
✅ 必须零时延闭环

---

## 5. Abort / Stop / Reset 的职责边界

### 5.1 Stop

* **属于事务内干扰**
* 用于终止当前事务
* 不等价于 Reset
* 必须能产生 Done（Stop Done）

---

### 5.2 Reset

* **属于系统级事务**
* 优先级高于所有普通事务
* 必须可在 Error 状态中触发
* Reset 本身也是一条完整事务

---

### 5.3 Abort

* 表示事务被非正常终止
* 必须：

  * 清理事务内部 latch
  * 清除 PhysicalDone 锁存
  * 不自动产生 LogicalDone

---

## 6. 上下层交互规范（关键）

### 6.1 推荐交互模型

| 层级    | 机制                  |
| ----- | ------------------- |
| 下 → 上 | **脉冲（Pulse）**       |
| 上 → 下 | **电平（Level）+ 事务边沿** |
| 跨层确认  | **锁存 + Commit**     |

---

### 6.2 锁存清理责任划分

| 锁存对象                | 清理者                     |
| ------------------- | ----------------------- |
| PhysicalDoneLatched | Commit / Abort / NewCmd |
| LogicalDoneLatched  | NewCmd / Abort          |
| Busy                | 自动派生（禁止手动清）             |

---

## 7. Busy 的设计原则（强制）

> **Busy ≠ Axis Busy
> Busy = 当前事务未完成**

### 7.1 Busy 的唯一来源

```text
Busy :=
(事务已开始)
AND (未 LogicalDone)
AND (未 Abort)
```

❌ 禁止 Busy 直接 OR Axis.Q_Busy
❌ 禁止 Busy 由状态位驱动

---

## 8. 设计流程方法论（必须遵循）

### 8.1 设计顺序（不可颠倒）

1. **列事务**
2. **画生命周期**
3. **覆盖干扰矩阵**
4. **定义 Done 语义**
5. **定义清理条件**
6. **最后才写代码**

> 任何跳过前 4 步直接写代码的行为，都是高风险设计。

---

## 9. 判定一段逻辑是否“合格”的 5 个问题

1. 这是不是一条事务？
2. 它有没有 PhysicalDone？
3. 它是不是等 Commit 才算完成？
4. 重复命令会不会卡 Busy？
5. Abort / Reset 是否能无条件回收？

**任一问题回答不出 → 不合格**

---

## 10. 规范等级声明

本规范为：

> **结构级规范（Structural Specification）**

优先级高于：

* 编码习惯
* 平台特性
* 厂商示例
* 历史代码

---

## 11. 结束语（设计原则宣言）

> **控制系统不是状态机拼装，
> 而是事务系统的工程实现。**

> **能证明完整性的逻辑，
> 才是可维护、可扩展、可迁移的逻辑。**

---

如果你愿意，下一步我可以帮你做三件事之一：

1. 把这份规范 **压缩成 1 页检查表**（写代码前用）
2. 做一个 **Servo / Cylinder 通用模板骨架**
3. 把它升级成 **v1.1（含 Process Engine 约束）**

你选一个。
